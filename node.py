from math import isinf
import numpy as np
import time
import random
from block import Block
from block import Blockchain
from transaction import Transaction
import constants


class Node(object):
  def __init__(self,env, id, type, network, badType):
    self.env = env
    #self.action = env.process(self.run())
    self.init = 1

    self.id = id
    self.type = type
    self.network = network  # in which network this node belongs to
    self.badType = badType

    self.seenTxns = {}  # txnid , time of all the transactions this node sees
    self.seenBlocks = {}
    self.pendBlks={}

    self.txnQueue = []   # list of txn this node sees and remaining for block formation
    #self.pending_txn = {}
    self.sentTxns = {}
    self.rcvdTxns = {}
    self.utxo = []  # list of unspent transactions
    self.adjNodes = []
    #self.longestChainLength = 1  # bcoz, genesis block is initialized

    self.blockchain = Blockchain() # honest chain

    # private selfish chain
    self.firstSelfishNode = None
    self.lastSelfishNode = None
    self.privateChain = []

  def run(self):
    print("inside run() of ",self.id)
    while True:
      txnGenInterarrivalTime = random.expovariate(1/constants.Tk)
      self._doHandleTransactions()
      yield self.env.timeout(txnGenInterarrivalTime)
      if self.init == 1:
        print("len of txn queue of ",self.id," is ",len(self.txnQueue))
        self.init = 0
        self.env.process(self.mining(self.env))

  def _doHandleTransactions(self):
    txnGeneratedAt = self.env.now
    receiverId = self.network.getRandomReceiever(self)
    coins = self.coinsOwned() * (random.random() / 2)
    self.deleteCoins(coins)
    txn = Transaction(self.id, receiverId, coins, txnGeneratedAt)
    # print("Transaction ",txn.id," generated by ",self.id," at ",txnGeneratedAt)
    self.seenTxns[txn.id] = txnGeneratedAt
    self.txnQueue.append(txn)
    self.env.process(self.broadcast_txn(txn, txnGeneratedAt))

  def runStubborn(self):
    while True:
      txnGenInterarrivalTime = random.expovariate(1/constants.Tk)
      self._doHandleTransactions() # Recv/Brdcst Txns
      yield self.env.timeout(txnGenInterarrivalTime)
      if self.init == 1: # start the mining process
        self.init = 0
        self.env.process(self.stubbornMining(self.env))

  def blockRecvStubborn(self, block, blkrcvdTime, Blk_latency, PrevBlockId):
    print("rcvd a blk by ", self.id, " but timeout for ",Blk_latency)
    yield self.env.timeout(Blk_latency)
    
    if block.id not in self.seenBlocks.keys():
      self.seenBlocks[block.id] = blkrcvdTime
      BlockParentID = PrevBlockId
      if self.blockchain.searchBlock(BlockParentID) is not None:  # the parent block exists in the blockchain
        self.blockchain.addBlockToParent(BlockParentID, block)
        # remove from txnqueue
        for txn in block.transactions:
          for s_txns in self.txnQueue:
            if txn.id == s_txns.id:
              self.txnQueue.remove(s_txns)
        #broadcast seen blk
        nextNodes = self.network.graph[self.id]
        print("broadcasting blk")
        for adjNodeIndex in nextNodes:
          adjNode = self.network.nodes[adjNodeIndex]
          Blk_latency1 = self.latency(adjNode.type, "block")
          BlkrcvTime1 = self.env.now + Blk_latency1
          self.env.process(adjNode.rcv_and_bdcst_blk(block, BlkrcvTime1, Blk_latency1,BlockParentID, self.env))
      else:
        self.pendBlks[block.id]=block
    yield self.env.timeout(1)

    pass

  def stubbornMining(self, env):
    while True:
      while len(self.txnQueue)<1: # can't build new block
        print("no of txns <1 for ",self.id)
        yield self.env.timeout(1)
      # Start private mining
      privateParent = None # where do we attach new block
      if(self.lastSelfishNode == None and len(self.privateChain) == 0): # attach it to genesis
        genesis = self.blockchain.chain.root.value
        self.firstSelfishNode = genesis # genesis
        privateParent = genesis 
        self.privateChain.append(privateParent)
      else: # attach new block to last selfish node
        privateParent = self.lastSelfishNode

      newBlockCretime = self.env.now
      newBlock = self.createBlk(newBlockCretime)
      ParentBlkId = privateParent.id
      chainLength = len(self.blockchain.getChainEndsWithBlock(privateParent))
      Blk_mean_Tk = random.expovariate(1 / constants.Tk)
      yield env.timeout(Blk_mean_Tk) # Mining time
      self.blockchain.addBlockToParent(ParentBlkId, newBlock)
      self.seenBlocks[newBlock.id] = newBlockCretime

      pass


  def generateTransaction(self,txnGeneratedAt):
    receiverId = self.network.getRandomReceiever(self)
    receiverNode = self.network.nodes[receiverId]
    coins = self.coinsOwned() * (random.random() / 2)
    self.deleteCoins(coins)
    txn = Transaction(self.id, receiverId, coins, txnGeneratedAt)
    #print("Transaction ",txn.id," generated by ",self.id," at ",txnGeneratedAt)
    self.seenTxns[txn.id] = txnGeneratedAt
    self.txnQueue.append(txn)
    #self.pending_txn[txn.id] = txn
    self.env.process(self.broadcast_txn(txn,txnGeneratedAt))
    yield self.env.timeout(1)

  def broadcast_txn(self, txn, txnGeneratedAt):
    seenNodeid1 = []
    seenNodeid2 = []
    #seenNodeids = []
    if txn.id in self.rcvdTxns.keys():
      seenNodeid1 = self.rcvdTxns[txn.id]
    if txn.id in self.sentTxns.keys():
      seenNodeid2 = self.sentTxns[txn.id]
    seenNodeids = list(set(seenNodeid2+seenNodeid1))
    nextNodes = self.network.graph[self.id]

    bdNodes = list(set(nextNodes) - set(seenNodeids))
    #print(self.id," broadcasts ",txn.id," to ",bdNodes)
    for adjNodeIndex in bdNodes:
      adjNode = self.network.nodes[adjNodeIndex]
      self.sentTxns.setdefault(txn.id, []).append(adjNodeIndex)
      Txnlatency = self.latency(adjNode.type, "transaction")
      Txnrcvtime = Txnlatency + txnGeneratedAt
      self.env.process(adjNode.rcv_txn(txn, self.id, Txnrcvtime,Txnlatency ))

    yield self.env.timeout(1)


  def rcv_txn(self, txn, txnSendr_Id, Txnrcvtime, Txnlatency):
    yield self.env.timeout(Txnlatency)
    #print("Transaction ",txn.id," received by ",self.id ," from ",txnSendr_Id," at ",Txnrcvtime)

    if txn.id not in self.rcvdTxns.keys():  # never seen new txn comes
      self.rcvdTxns.setdefault(txn.id, []).append(txnSendr_Id)
      self.txnQueue.append(txn)
      self.seenTxns[txn.id]=Txnrcvtime
      #self.pending_txn[txn.id] = txn
      # if rcv is self.id add to utxo
      if txn.receiver == self.id:
        self.utxo.append(txn)
      self.env.process(self.broadcast_txn(txn,Txnrcvtime))
    else:
      self.rcvdTxns.setdefault(txn.id, []).append(txnSendr_Id)

    yield self.env.timeout(1)

  def latency(self, node_type, msg_type):
    m=0
    Pij = np.random.uniform(10, 500)  # in ms as per question
    if self.type == 'fast' and node_type == 'fast':
      Cij = 100 * pow(10, 3)  # in ms
    else:
      Cij = 5 * pow(10, 3)

    if msg_type == "block":
      m = 8 * (10 ** 6)

    mean = 96 * pow(10, 3) / Cij
    Dij = np.random.exponential((1 / mean), 1)[0]
    tot_delay = Pij + Dij + (m / Cij)
    return (tot_delay/1000)


  def coinsOwned(self):  # calculates coins owned using utxo
    totalCoins = 0
    for txn in self.utxo:
      totalCoins += txn.coins
    return totalCoins

  def deleteCoins(self, coins):  # deletes transactions from utxo whose outputs are used
    deletedYet = 0
    toDelete = []
    for i in range(len(self.utxo)):
      needCoins = coins - deletedYet
      if needCoins == 0:
        break
      if self.utxo[i].coins >= needCoins:
        self.utxo[i].coins -= needCoins
        if self.utxo[i].coins == 0:
          toDelete.append(i)
        break
      else:
        deletedYet += self.utxo[i].coins
        toDelete.append(i)
    for index in toDelete:
      self.utxo[index] = 0
    self.utxo = [i for i in self.utxo if i != 0]

  def addTransaction(self, transaction):
    self.txnQueue.append(transaction)

  def genCoinbaseTxn(self):
    txn = Transaction(None,self.id,50)
    self.utxo.append(txn)
    self.txnQueue.append(txn)
    self.seenTxns[txn.id]=self.env.now
    return



  def rcv_and_bdcst_blk(self, block, blkrcvdTime, Blk_latency, PrevBlockId, env):
    #initir = 0
    # while initir == 0:
    print("rcvd a blk by ", self.id, " but timeout for ",Blk_latency)
    yield self.env.timeout(Blk_latency)

    if block.id not in self.seenBlocks.keys():
      self.seenBlocks[block.id]=blkrcvdTime
      BlockParentID = PrevBlockId
      if self.blockchain.searchBlock(BlockParentID) is not None:  # the parent block exists in the blockchain
        self.blockchain.addBlockToParent(BlockParentID, block)
        # remove from txnqueue
        for txn in block.transactions:
          for s_txns in self.txnQueue:
            if txn.id == s_txns.id:
              self.txnQueue.remove(s_txns)
        #broadcast seen blk
        nextNodes = self.network.graph[self.id]
        print("broadcasting blk")
        for adjNodeIndex in nextNodes:
          adjNode = self.network.nodes[adjNodeIndex]
          Blk_latency1 = self.latency(adjNode.type, "block")
          BlkrcvTime1 = env.now + Blk_latency1
          self.env.process(adjNode.rcv_and_bdcst_blk(block, BlkrcvTime1, Blk_latency1,BlockParentID, env))
      else:
        self.pendBlks[block.id]=block
    yield self.env.timeout(1)

  def mining(self,env):
    while True:
      print("mining started for ",self.id)
      while len(self.txnQueue)<1:
        print("no of txns <1 for ",self.id)
        yield self.env.timeout(1)
      newBlock = self.createBlk(self.env.now)
      print("minig blk created fro ",self.id)
      newBlockCretime = self.env.now
      ParentBlkId = self.blockchain.getDeepestBlockID()
      longestchainLen = len(self.blockchain.getLongestChain())
      Blk_mean_Tk = random.expovariate(1 / constants.Tk)
      yield env.timeout(Blk_mean_Tk)
      if(len(self.blockchain.getLongestChain()) == longestchainLen) and (self.blockchain.getDeepestBlockID() == ParentBlkId):
        print("minig blk added for ",self.id)
        self.blockchain.addBlockToParent(ParentBlkId,newBlock)
        self.seenBlocks[newBlock.id] = newBlockCretime
        #bdcast created blk
        nextNodes = self.network.graph[self.id]
        for adjNodeIndex in nextNodes:
          adjNode = self.network.nodes[adjNodeIndex]
          Blk_latency1 = self.latency(adjNode.type, "block")
          BlkrcvTime1 = newBlockCretime + Blk_latency1
          print("bdcast to ",adjNodeIndex)
          self.env.process(adjNode.rcv_and_bdcst_blk(newBlock, BlkrcvTime1, Blk_latency1, ParentBlkId, self.env))
          yield self.env.timeout(1)
      else:
        print("minig blk not added ",self.id)
        for trxns in newBlock.transactions:
          self.txnQueue.append(trxns)

  def createBlk(self, newBlk_crTime):
    if len(self.txnQueue) > 10: # take only top 10 pending txns
      PendingTxnSubset = self.txnQueue[0:10]
      self.txnQueue = self.txnQueue[10:]
    else: # take all pending txns
      PendingTxnSubset = self.txnQueue
      self.txnQueue = []
    newblk = Block(PendingTxnSubset, newBlk_crTime, self.id+1)
    return newblk

  #def broadcastBlk(self, newBlkCreated, newBlkCreated_Time):





  def printNode(self):
    print("nodeId: ", self.id)
    print("type:", self.type)
    # print("utxo:", self.utxo)
    # print("txnQueue:", self.txnQueue)
    # print("txnSent:", self.txnSent)
    print("--------------------------")

  def printTxn(self):
    for txnid in self.seenTxns.keys():
      if txnid in self.sentTxns.keys():
        print("Transaction ",txnid," received at ",self.seenTxns[txnid]," by ",str(list(self.sentTxns[txnid])))
      else:
        print("Transaction ", txnid," generated at ",self.seenTxns[txnid])






