import numpy as np
import time
import random
from block import Block
from block import Blockchain
from transaction import Transaction
import constants


class Node(object):
    def __init__(self,env, id, type,miner_typ, network):
        self.env = env
        #self.action = env.process(self.run())
        self.init = 1
        self.adjNodes = []
        self.id = id
        self.type = type
        self.miner_type = miner_typ # honest or selfish
        self.network = network  # in which network this node belongs to

        self.seenTxns = {}  # txnid , time of all the transactions this node sees
        self.seenBlocks = {}
        self.pendBlks={}
        self.selfishnodeSeenblks=[]
        self.minedBlks=[]

        self.txnQueue = []   # list of txn this node sees and remaining for block formation
        #self.pending_txn = {}
        self.sentTxns = {}
        self.rcvdTxns = {}
        self.utxo = []  # list of unspent transactions
        #self.longestChainLength = 1  # bcoz, genesis block is initialized

        self.blockchain = Blockchain()

        self.CurrPrivateChain=[]
        self.statechain=[0]
        self.privateblkchain={} #{"blkid" : blk}
        self.FullPrvChain=[]
        self.PrvChainList = {}



    def run(self):
        print("inside run() of ",self.id)
        #init = 1
        while True:
            txnGenInterarrivalTime = random.expovariate(1/constants.Tk)
            txnGeneratedAt = self.env.now
            #self.env.process(self.generateTransaction(txnGeneratedAt))
            receiverId = self.network.getRandomReceiever(self)
            receiverNode = self.network.nodes[receiverId]
            coins = self.coinsOwned() * (random.random() / 2)
            self.deleteCoins(coins)
            txn = Transaction(self.id, receiverId, coins, txnGeneratedAt)
            # print("Transaction ",txn.id," generated by ",self.id," at ",txnGeneratedAt)
            self.seenTxns[txn.id] = txnGeneratedAt
            self.txnQueue.append(txn)
            # self.pending_txn[txn.id] = txn
            self.env.process(self.broadcast_txn(txn, txnGeneratedAt))
            yield self.env.timeout(txnGenInterarrivalTime)
            if self.init == 1:
                #print("len of txn queue of ",self.id," is ",len(self.txnQueue))
                self.init = 0
                if(self.id == constants.TotalNodes-1):
                    self.env.process(self.sefishMining(self.env))
                else:
                    self.env.process(self.mining(self.env))



    def generateTransaction(self,txnGeneratedAt):
        receiverId = self.network.getRandomReceiever(self)
        receiverNode = self.network.nodes[receiverId]
        coins = self.coinsOwned() * (random.random() / 2)
        self.deleteCoins(coins)
        txn = Transaction(self.id, receiverId, coins, txnGeneratedAt)
        #print("Transaction ",txn.id," generated by ",self.id," at ",txnGeneratedAt)
        self.seenTxns[txn.id] = txnGeneratedAt
        self.txnQueue.append(txn)
        #self.pending_txn[txn.id] = txn
        self.env.process(self.broadcast_txn(txn,txnGeneratedAt))
        yield self.env.timeout(1)

    def broadcast_txn(self, txn,txnGeneratedAt):
        """bdcast_flg1 = 0  # rcvd txn
        bdcast_flg2 = 0  # sent_txn
        nextNodes = self.network.graph[self.id]
        for adjNodeIndex in nextNodes:
            adjNode = self.network.nodes[adjNodeIndex]
            if txn.id in self.rcvdTxns.keys():  # not a self generated trxn but a rcvd trxn
                if adjNodeIndex in self.rcvdTxns[txn.id]:  # rcvd from this node
                    bdcast_flg1 = 1  # don't broadcast
            # else : self generated txn , so broad cast
            if txn.id in self.sentTxns.keys():  # this trxn already sent to some nodes
                if adjNodeIndex in self.sentTxns[txn.id]:
                    bdcast_flg2 = 1  # if txn already sent to this adjnode don't resend

            if bdcast_flg2 != 1 and bdcast_flg1 != 1:
                self.sentTxns.setdefault(txn.id, []).append(adjNodeIndex)
                Txnrcvtime = self.latency(self.type , "transaction")
                self.env.process(adjNode.rcv_txn(txn, self.id, Txnrcvtime)) """

        seenNodeid1 = []
        seenNodeid2 = []
        #seenNodeids = []
        if txn.id in self.rcvdTxns.keys():
            seenNodeid1 = self.rcvdTxns[txn.id]
        if txn.id in self.sentTxns.keys():
            seenNodeid2 = self.sentTxns[txn.id]
        seenNodeids = list(set(seenNodeid2+seenNodeid1))
        nextNodes = self.network.graph[self.id]

        bdNodes = list(set(nextNodes) - set(seenNodeids))
        #print(self.id," broadcasts ",txn.id," to ",bdNodes)
        for adjNodeIndex in bdNodes:
            adjNode = self.network.nodes[adjNodeIndex]
            self.sentTxns.setdefault(txn.id, []).append(adjNodeIndex)
            Txnlatency = self.latency(adjNode.type, "transaction")
            Txnrcvtime = Txnlatency + txnGeneratedAt
            self.env.process(adjNode.rcv_txn(txn, self.id, Txnrcvtime,Txnlatency ))

        yield self.env.timeout(1)

    """ if this transxn is already seen what to do ??????  """

    def rcv_txn(self, txn, txnSendr_Id, Txnrcvtime,Txnlatency ):
        #yield self.env.timeout(Txnlatency)
        #print("Transaction ",txn.id," received by ",self.id ," from ",txnSendr_Id," at ",Txnrcvtime)

        if txn.id not in self.rcvdTxns.keys():  # never seen new txn comes
            self.rcvdTxns.setdefault(txn.id, []).append(txnSendr_Id)
            self.txnQueue.append(txn)
            self.seenTxns[txn.id]=Txnrcvtime
            #self.pending_txn[txn.id] = txn
            # if rcv is self.id add to utxo
            if txn.receiver == self.id:
                self.utxo.append(txn)
            self.env.process(self.broadcast_txn(txn,Txnrcvtime))
        else:
            self.rcvdTxns.setdefault(txn.id, []).append(txnSendr_Id)

        yield self.env.timeout(1)

    def latency(self, node_type, msg_type):
        m=0
        Pij = constants.Pij # in ms as per question
        if self.type == 'fast' and node_type == 'fast':
            Cij = 100 * pow(10, 3)  # in ms
        else:
            Cij = 5 * pow(10, 3)

        if msg_type == "block":
            m = 8 * (10 ** 6)

        mean = 96 * pow(10, 3) / Cij
        Dij = np.random.exponential((1 / mean), 1)[0]
        tot_delay = Pij + Dij + (m / Cij)
        return (tot_delay/1000)


    def coinsOwned(self):  # calculates coins owned using utxo
        totalCoins = 0
        for txn in self.utxo:
            totalCoins += txn.coins
        return totalCoins

    def deleteCoins(self, coins):  # deletes transactions from utxo whose outputs are used
        deletedYet = 0
        toDelete = []
        for i in range(len(self.utxo)):
            needCoins = coins - deletedYet
            if needCoins == 0:
                break
            if self.utxo[i].coins >= needCoins:
                self.utxo[i].coins -= needCoins
                if self.utxo[i].coins == 0:
                    toDelete.append(i)
                break
            else:
                deletedYet += self.utxo[i].coins
                toDelete.append(i)
        for index in toDelete:
            self.utxo[index] = 0
        self.utxo = [i for i in self.utxo if i != 0]

    def addTransaction(self, transaction):
        self.txnQueue.append(transaction)

    def genCoinbaseTxn(self):
        txn = Transaction(None,self.id,50)
        self.utxo.append(txn)
        self.txnQueue.append(txn)
        self.seenTxns[txn.id]=self.env.now
        return



    def rcv_and_bdcst_blk(self,block,blkrcvdTime,Blk_latency,PrevBlockId,env):
        #initir = 0
        # while initir == 0:
        #print("rcvd a blk by ", self.id, " but timeout for ",Blk_latency)
        yield self.env.timeout(Blk_latency)
        #print("rcv and bdcast of other node ",self.id)
        if block.id not in self.seenBlocks.keys():

            if self.blockchain.searchBlock(PrevBlockId) is not None:
                self.seenBlocks[block.id] = blkrcvdTime
                BlockParentID = PrevBlockId
                # the parent block exists in the blockchain
                # deepestBlkId = self.blockchain.getDeepestBlockID()
                # longestchainLen = len(self.blockchain.getLongestChain())
                self.blockchain.addBlockToParent(BlockParentID, block)
                # if (len(self.blockchain.getLongestChain()) > longestchainLen) and (
                #         self.blockchain.getDeepestBlockID() != deepestBlkId):
                #   self.env.process(self.mining(self.env))

                # remove from txnqueue
                for txn in block.transactions:
                    for s_txns in self.txnQueue:
                        if txn.id == s_txns.id:
                            self.txnQueue.remove(s_txns)
                #broadcast seen blk
                nextNodes = self.network.graph[self.id]
                #print("broadcasting blk")
                for adjNodeIndex in nextNodes:
                    if(adjNodeIndex == (constants.TotalNodes-1)):
                        adjNode = self.network.nodes[adjNodeIndex]
                        Blk_latency1 = self.latency(adjNode.type, "block")
                        BlkrcvTime1 = env.now + Blk_latency1
                        self.env.process(
                            adjNode.rcv_blk_selfish(block, BlkrcvTime1, Blk_latency1, BlockParentID, env))
                    else:
                        adjNode = self.network.nodes[adjNodeIndex]
                        Blk_latency1 = self.latency(adjNode.type, "block")
                        BlkrcvTime1 = env.now + Blk_latency1
                        self.env.process(adjNode.rcv_and_bdcst_blk(block, BlkrcvTime1, Blk_latency1,BlockParentID, env))
            else:
                self.pendBlks[block.id]=block
        yield self.env.timeout(1)

        """ self.seenBlocks[block.id] = blkrcvdTime
        BlockParentID = block.prev
        if self.blockchain.searchBlock(BlockParentID) is not None:  # the parent block exists in the blockchain
            self.blockchain.addBlockToParent(BlockParentID, block)
            # remove from txnqueue
            for txn in block.transactions:
                for s_txns in self.txnQueue:
                    if txn.id == s_txns.id:
                        self.txnQueue.remove(s_txns)

            if len(self.blockchain.getLongestChain()) > self.longestChainLength:
                self.longestChainLength = self.longestChainLength + 1
                mining_longestChainLen = len(self.blockchain.getLongestChain()) # mining of new blk starts
                newBlkCreated_Time = env.now
                newBlkCreated = self.createBlk(newBlkCreated_Time)
                #self.mining(newBlkCreated, newBlkCreated_Time, mining_longestChainLen,env)
                Blk_mean_Tk = random.expovariate(1 / constants.Tk)
                yield env.timeout(Blk_mean_Tk)
                if len(self.blockchain.getLongestChain()) == mining_longestChainLen:
                    #newBlockParentID = self.blockchain.getDeepestBlock().ID
                    #self.blockchain.addBlockToParent(newBlockParentID, newBlkCreated)
                    self.blockchain.addBlock(newBlkCreated)
                    self.longestChainLength = self.longestChainLength + 1
                    env.process(self.broadcastBlk(newBlkCreated ,newBlkCreated_Time))
                else:
                    for trxns in newBlkCreated.transactions:
                        self.txnQueue.append(trxns)
        yield self.env.timeout(1) """

    def mining(self,env):
        while True:
            #print("mining started for ",self.id)
            while len(self.txnQueue)<1:
                #print("no of txns <1 for ",self.id)
                yield self.env.timeout(1)
            newBlock = self.createBlk(self.env.now)
            #print("minig blk created fro ",self.id)
            newBlockCretime = self.env.now
            ParentBlkId = self.blockchain.getDeepestBlockID()
            longestchainLen = len(self.blockchain.getLongestChain())
            nodehashpower = (1-constants.alpha)/(constants.TotalNodes-1)
            Blk_mean_Tk = random.expovariate(1 / (constants.Tk/nodehashpower))
            yield env.timeout(Blk_mean_Tk)
            if(len(self.blockchain.getLongestChain()) == longestchainLen) and (self.blockchain.getDeepestBlockID() == ParentBlkId):
                #print("minig blk added for ",self.id)
                self.blockchain.addBlockToParent(ParentBlkId,newBlock)
                self.seenBlocks[newBlock.id] = newBlockCretime
                self.minedBlks.append(newBlock.id)
                #bdcast created blk
                nextNodes = self.network.graph[self.id]
                for adjNodeIndex in nextNodes:
                    if (adjNodeIndex == (constants.TotalNodes - 1)):
                        adjNode = self.network.nodes[adjNodeIndex]
                        Blk_latency1 = self.latency(adjNode.type, "block")
                        BlkrcvTime1 = newBlockCretime + Blk_latency1
                        #print("bdcast to ",adjNodeIndex)
                        self.env.process(adjNode.rcv_blk_selfish(newBlock, BlkrcvTime1, Blk_latency1, ParentBlkId, self.env))
                    else:
                        adjNode = self.network.nodes[adjNodeIndex]
                        Blk_latency1 = self.latency(adjNode.type, "block")
                        BlkrcvTime1 = newBlockCretime + Blk_latency1
                        # print("bdcast to ",adjNodeIndex)
                        self.env.process(
                            adjNode.rcv_and_bdcst_blk(newBlock, BlkrcvTime1, Blk_latency1, ParentBlkId, self.env))

                    yield self.env.timeout(1)
            else:
                #print("minig blk not added ",self.id)
                for trxns in newBlock.transactions:
                    self.txnQueue.append(trxns)
                #break
        #yield self.env.timeout(1)

    def createBlk(self, newBlk_crTime):
        """   TxnsInBlkchain = []
        PendingTxnSubset=[]
        longestChain = self.blockchain.getLongestChain()
        for blk in longestChain:
            for txn in blk.transactions:
                TxnsInBlkchain.append(txn)
        PendingTxnSubset = list(set(self.txnQueue) - set(TxnsInBlkchain)) """
        if len(self.txnQueue) > 10:
            PendingTxnSubset = self.txnQueue[0:10]
            self.txnQueue = self.txnQueue[10:]
        else:
            PendingTxnSubset = self.txnQueue
            self.txnQueue = []
        newblk = Block(PendingTxnSubset, newBlk_crTime, self.id+1)
        return newblk

    def broadcastBlk(self, newBlkCreated, newBlkCreated_Time):
        pass

    def rcv_blk_selfish(self,block,blkrcvdTime,Blk_latency,PrevBlockId,env):
        yield self.env.timeout(Blk_latency)
        print("rcv_blk_selfish ",block.id," with parentid ",PrevBlockId)
        print("for ",block.id," seen blocks is ",self.seenBlocks.keys())
        if block.id not in self.seenBlocks.keys():
            print("seeing ",block.id," for the first time")
            if self.blockchain.searchBlock(PrevBlockId) is not None:
                print("Block ",block.id," added to chain may not main chain")
                self.seenBlocks[block.id] = blkrcvdTime
                BlockParentID = PrevBlockId
                longestchainLen = len(self.blockchain.getLongestChain())
                print("before adding ",block.id," to chainlen ",longestchainLen)
                self.blockchain.addBlockToParent(BlockParentID, block)
                print("After adding ", block.id, " to chainlen ",len(self.blockchain.getLongestChain()))

                if (len(self.blockchain.getLongestChain()) > longestchainLen) :
                    print("Block ",block.id," added to main chain")
                    lead = len(self.CurrPrivateChain)-1
                    #print("lead ",lead," for ",block.id)
                    #mainChainLen = len(self.blockchain.getLongestChain())
                    if(self.statechain[0] == 0):
                        self.FullPrvChain = []
                        self.CurrPrivateChain=[]
                        self.CurrPrivateChain.append(block.id)
                        print("state 0 current prv chain ",self.CurrPrivateChain)
                        self.FullPrvChain.append(block.id)
                        self.statechain[0]=0
                    elif (self.statechain[0] == 1):
                        print("state 1 ",self.CurrPrivateChain)
                        self.blockchain.addBlockToParent(self.CurrPrivateChain[0],self.privateblkchain[self.CurrPrivateChain[1]])
                        self.seenBlocks[self.CurrPrivateChain[1]]=self.env.now
                        #broadcast(privaetblk)
                        self.selfish_brdcast(self.privateblkchain[self.CurrPrivateChain[1]],self.CurrPrivateChain[0],self.env)
                        del self.CurrPrivateChain[0]
                        self.statechain[0]=-1
                        print("curr prv chain after brdcast in state 1 ",self.CurrPrivateChain)
                        print("now resut state ",self.statechain[0])
                    elif(self.statechain[0]== -1):
                        print("state -1 ", self.CurrPrivateChain)
                        self.FullPrvChain = []
                        self.CurrPrivateChain = []
                        self.CurrPrivateChain.append(block.id)
                        # print("lead <1 current prv chain ",self.CurrPrivateChain)
                        self.FullPrvChain.append(block.id)
                        self.statechain[0] = 0
                        print("curr prv chain after brdcast in state -1 ", self.CurrPrivateChain)
                        print("now resut state ", self.statechain[0])

                    elif(self.statechain[0] ==2):
                        print("state 2 ", self.CurrPrivateChain)
                        #print("keys in prv blk dict ",self.privateblkchain.keys())
                        self.blockchain.addBlockToParent(self.CurrPrivateChain[0],
                                                         self.privateblkchain[self.CurrPrivateChain[1]])
                        self.seenBlocks[self.CurrPrivateChain[1]] = self.env.now
                        # broadcast(privaetblk)
                        self.selfish_brdcast(self.privateblkchain[self.CurrPrivateChain[1]], self.CurrPrivateChain[0],
                                             self.env)
                        del self.CurrPrivateChain[0]
                        #self.env.timeout(1)
                        self.blockchain.addBlockToParent(self.CurrPrivateChain[0],
                                                         self.privateblkchain[self.CurrPrivateChain[1]])
                        self.seenBlocks[self.CurrPrivateChain[1]] = self.env.now
                        # broadcast(privaetblk)
                        self.selfish_brdcast(self.privateblkchain[self.CurrPrivateChain[1]], self.CurrPrivateChain[0],
                                             self.env)
                        del self.CurrPrivateChain[0]
                        self.FullPrvChain = []
                        self.FullPrvChain.append(self.CurrPrivateChain[0])
                        self.CurrPrivateChain = []
                        self.CurrPrivateChain.append(self.FullPrvChain[0])
                        # print("lead <1 current prv chain ",self.CurrPrivateChain)
                        self.statechain[0] = 0
                        print("curr prv chain after brdcast in state 2 ", self.CurrPrivateChain)
                        print("now resut state ", self.statechain[0])



                    else:
                        print("state > 2 i.e., ",self.statechain[0]," ", self.CurrPrivateChain)
                        self.blockchain.addBlockToParent(self.CurrPrivateChain[0],
                                                         self.privateblkchain[self.CurrPrivateChain[1]])
                        self.seenBlocks[self.CurrPrivateChain[1]] = self.env.now
                        # broadcast(privaetblk)
                        self.selfish_brdcast(self.privateblkchain[self.CurrPrivateChain[1]], self.CurrPrivateChain[0],
                                             self.env)
                        del self.CurrPrivateChain[0]
                        self.statechain[0]=self.statechain[0]-1
                        print("curr prv chain after brdcast in state >2 i.e., ",self.statechain[0]," ", self.CurrPrivateChain)
                        print("now resut state ", self.statechain[0])

                for txn in block.transactions:
                    for s_txns in self.txnQueue:
                        if txn.id == s_txns.id:
                            self.txnQueue.remove(s_txns)
        yield self.env.timeout(1)



    def printNode(self):
        print("nodeId: ", self.id)
        print("type:", self.type)
        # print("utxo:", self.utxo)
        # print("txnQueue:", self.txnQueue)
        # print("txnSent:", self.txnSent)
        print("--------------------------")

    def printTxn(self):
        for txnid in self.seenTxns.keys():
            if txnid in self.sentTxns.keys():
                print("Transaction ",txnid," received at ",self.seenTxns[txnid]," by ",str(list(self.sentTxns[txnid])))
            else:
                print("Transaction ", txnid," generated at ",self.seenTxns[txnid])

    def sefishMining(self,env):
        if(len(self.CurrPrivateChain) == 0):
            genesisBlkId=self.blockchain.getDeepestBlockID()
            self.CurrPrivateChain.append(genesisBlkId)
            #print("genesis curr prv chain ",self.CurrPrivateChain)
            self.FullPrvChain.append(genesisBlkId)
            self.statechain=[0]
            #self.statechain.append(genesisBlkId)
        while True:
            print("mining started for ", self.id)
            while len(self.txnQueue) < 1:
                #print("no of txns <1 for ", self.id)
                yield self.env.timeout(1)
            newBlock = self.createBlk(self.env.now)
            print("minig blk created fro ", self.id)
            PrevParentID = self.FullPrvChain[0]
            Blk_mean_Tk = random.expovariate(1 / (constants.Tk/constants.alpha))
            yield env.timeout(Blk_mean_Tk)
            while (len(self.FullPrvChain) ==0):
                yield self.env.timeout(1)
            if(self.FullPrvChain[0] == PrevParentID):
                print("private blk added")
                #self.minedBlks.append(newBlock.id)
                #self.privateblkchain[newBlock.id] = newBlock
                #self.FullPrvChain.append(newBlock.id)
                #self.CurrPrivateChain.append(newBlock.id)

                #self.PrvChainList.setdefault(self.FullPrvChain[0], []).append(newBlock.id)
                #print(self.PrvChainList)
                #print(self.CurrPrivateChain)
                if(self.statechain[0] == 0):
                    print("minign start statechain 0 for ",newBlock.id)
                    self.minedBlks.append(newBlock.id)
                    self.privateblkchain[newBlock.id] = newBlock
                    self.FullPrvChain.append(newBlock.id)
                    self.CurrPrivateChain.append(newBlock.id)

                    self.PrvChainList.setdefault(self.FullPrvChain[0], []).append(newBlock.id)
                    print(self.PrvChainList)
                    print(self.CurrPrivateChain)
                    self.statechain[0]=1
                    print("After mining blk ",newBlock.id," added state 1")
                elif(self.statechain[0]== -1 ): #here -1 is state 0' in markov state diagram
                    print("minign start statechain -1 for ", newBlock.id)
                    self.minedBlks.append(newBlock.id)
                    self.PrvChainList.setdefault(self.FullPrvChain[0], []).append(newBlock.id)
                    self.blockchain.addBlockToParent(self.CurrPrivateChain[0],newBlock)
                    self.seenBlocks[newBlock.id]=self.env.now
                    self.selfish_brdcast(newBlock, self.CurrPrivateChain[0],
                                         self.env)
                    self.statechain[0]=0
                    self.FullPrvChain = []
                    self.CurrPrivateChain = []
                    self.CurrPrivateChain.append(newBlock.id)
                    # print("lead <1 current prv chain ",self.CurrPrivateChain)
                    self.FullPrvChain.append(newBlock.id)
                    print(self.PrvChainList)
                    print(self.CurrPrivateChain)
                    print("After mining blk ", newBlock.id, " added state 0")
                elif(self.statechain[0]>=1):
                    print("minign start statechain ",self.statechain[0]," for ", newBlock.id)
                    self.minedBlks.append(newBlock.id)
                    self.privateblkchain[newBlock.id] = newBlock
                    self.FullPrvChain.append(newBlock.id)
                    self.CurrPrivateChain.append(newBlock.id)

                    self.PrvChainList.setdefault(self.FullPrvChain[0], []).append(newBlock.id)
                    self.statechain[0] = self.statechain[0]+1
                    print(self.PrvChainList)
                    print(self.CurrPrivateChain)
                    print("After mining blk ", newBlock.id, " added state ",self.statechain[0])
                else:
                    print("minig selfish error")



            else:
                for trxns in newBlock.transactions:
                    self.txnQueue.append(trxns)
                yield self.env.timeout(1)

    """def rcv_blk_selfish(self, honestBlk, HblkrcvdTime, HBlk_latency, HPrevBlockId, env):
        yield self.env.timeout(HBlk_latency)
        print("rcvd ",honestBlk.id," and seenblks list ",self.selfishnodeSeenblks)
        if honestBlk.id not in self.selfishnodeSeenblks:
            print("seeing ",honestBlk.id," for first time")
            if self.blockchain.searchBlock(HPrevBlockId) is not None:
                print("Blkid's ",honestBlk.id," parent id ",HPrevBlockId," is in blkchain")
                longestChainLen = len(self.blockchain.getLongestChain())
                print("len before adding ",longestChainLen)
                self.blockchain.addBlockToParent(HPrevBlockId,honestBlk)
                self.selfishnodeSeenblks.append(honestBlk.id)
                print("seen blks after adding ",self.selfishnodeSeenblks)
                if(len(self.blockchain.getLongestChain()) > longestChainLen):
                    lead=len(self.CurrPrivateChain)-1
                    print("lead ",lead)
                    if(lead<1):
                        self.FullPrvChain = []
                        self.CurrPrivateChain = []
                        self.CurrPrivateChain.append(honestBlk.id)
                        print("lead <1 current prv chain ", self.CurrPrivateChain)
                        self.FullPrvChain.append(honestBlk.id)
                    elif(lead==1):
                        print("lead 1 ", self.CurrPrivateChain)
                        self.blockchain.addBlockToParent(self.CurrPrivateChain[0],
                                                         self.privateblkchain[self.CurrPrivateChain[1]])
                        self.selfishnodeSeenblks.append(self.CurrPrivateChain[1])
                        print("selfish node seen blks ",self.selfishnodeSeenblks)
                        # broadcast(privaetblk)
                        self.selfish_brdcast(self.privateblkchain[self.CurrPrivateChain[1]], self.CurrPrivateChain[0],
                                             self.env)
                        del self.CurrPrivateChain[0]
                    elif(lead == 2):
                        print("lead 2 ", self.CurrPrivateChain)
                        print("keys in prv blk dict ", self.privateblkchain.keys())
                        self.blockchain.addBlockToParent(self.CurrPrivateChain[0],
                                                         self.privateblkchain[self.CurrPrivateChain[1]])
                        self.selfishnodeSeenblks.append(self.CurrPrivateChain[1])
                        print("selfish node seen blks ", self.selfishnodeSeenblks)
                        # broadcast(privaetblk)
                        self.selfish_brdcast(self.privateblkchain[self.CurrPrivateChain[1]], self.CurrPrivateChain[0],
                                             self.env)
                        del self.CurrPrivateChain[0]
                        # self.env.timeout(1)
                        self.blockchain.addBlockToParent(self.CurrPrivateChain[0],
                                                         self.privateblkchain[self.CurrPrivateChain[1]])
                        self.selfishnodeSeenblks.append(self.CurrPrivateChain[1])
                        print("selfish node seen blks ", self.selfishnodeSeenblks)
                        # broadcast(privaetblk)
                        self.selfish_brdcast(self.privateblkchain[self.CurrPrivateChain[1]], self.CurrPrivateChain[0],
                                             self.env)
                        del self.CurrPrivateChain[0]
                    else:
                        print("lead > 2 ", self.CurrPrivateChain)
                        self.blockchain.addBlockToParent(self.CurrPrivateChain[0],
                                                         self.privateblkchain[self.CurrPrivateChain[1]])
                        self.selfishnodeSeenblks.append(self.CurrPrivateChain[1])
                        print("selfish node seen blks ", self.selfishnodeSeenblks)
                        # broadcast(privaetblk)
                        self.selfish_brdcast(self.privateblkchain[self.CurrPrivateChain[1]], self.CurrPrivateChain[0],
                                             self.env)
                        del self.CurrPrivateChain[0]

        yield self.env.timeout(1)"""

    def selfish_brdcast(self,block,BlockParentID,env):
        nextNodes = self.network.graph[self.id]
        for adjNodeIndex in nextNodes:
            if (adjNodeIndex == (constants.TotalNodes - 1)):
                adjNode = self.network.nodes[adjNodeIndex]
                Blk_latency1 = self.latency(adjNode.type, "block")
                BlkrcvTime1 = env.now + Blk_latency1
                self.env.process(adjNode.rcv_blk_selfish(block, BlkrcvTime1, Blk_latency1, BlockParentID, env))
            else:
                adjNode = self.network.nodes[adjNodeIndex]
                Blk_latency1 = self.latency(adjNode.type, "block")
                BlkrcvTime1 = env.now + Blk_latency1
                self.env.process(adjNode.rcv_and_bdcst_blk(block, BlkrcvTime1, Blk_latency1, BlockParentID, env))

    def printPrvChain(self):
        print(self.PrvChainList)
        #print(self.privateblkchain)





